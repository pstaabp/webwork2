package Utils::GeneralUtils;
use base qw(Exporter);

### this is a number of subrotines from the webwork2 version of WeBWorK::Utils

use Dancer ':syntax';
use strict;
use warnings;
use DateTime;
use DateTime::TimeZone;

our @EXPORT    = ();

our @EXPORT_OK = qw(writeConfigToFile getCourseSettingsWW2);



# the following are used for loading settings in the WW2 way.  
# we should change the settings so they are stored as a JSON file instead.  This
# eliminate the need for these subroutines.  

### pstaab: I think a nearly identical version of this is in Utils::CourseUtils

sub getCourseSettingsWW2 {
    my $ce = shift; 

	my $ConfigValues = $ce->{ConfigValues};

	# get the list of theme folders in the theme directory and remove . and ..
	my $themeDir = $ce->{webworkDirs}{themes};
	opendir(my $dh, $themeDir) || die "can't opendir $themeDir: $!";
	my $themes =[grep {!/^\.{1,2}$/} sort readdir($dh)];


	foreach my $oneConfig (@$ConfigValues) {
		foreach my $hash (@$oneConfig) {
			if (ref($hash) eq "HASH") {
				my $string = $hash->{var};
				if ($string =~ m/^\w+$/) {
					$string =~ s/^(\w+)$/\{$1\}/;
				} else {
					$string =~ s/^(\w+)/\{$1\}->/;
				}
				$hash->{value} = eval('$ce->' . $string);

				if ($hash->{var} eq 'defaultTheme'){
					$hash->{values} = $themes;	
				}
			}
		}
	}


	my $tz = DateTime::TimeZone->new( name => $ce->{siteDefaults}->{timezone}); 
	my $dt = DateTime->now();

	my @tzabbr = ("tz_abbr", $tz->short_name_for_datetime( $dt ));

	push(@$ConfigValues, \@tzabbr);

	return $ConfigValues;
}



sub writeConfigToFile {

	my ($ce,$config) = @_;

	my $filename = $ce->{courseDirs}->{root} . "/simple.conf";

		my $fileoutput = "#!perl
# This file is automatically generated by WeBWorK's web-based
# configuration module.  Do not make changes directly to this
# file.  It will be overwritten the next time configuration
# changes are saved.\n\n";


	# read in the file 

	my @raw_data =();
	if (-e $filename){
		open(DAT, $filename) || die("Could not open file!");
		@raw_data=<DAT>;
		close(DAT);
	} 

	my $line;
	my $varFound = 0; 

	foreach $line (@raw_data)
	{
		chomp $line;
	 	if ($line =~ /^\$/) {
	 		my ($var,$value) = ($line =~ /^\$(.*)\s+=\s+(.*);$/);
	 		if ($var eq $config->{var}){ 
	 			$fileoutput .= writeLine($config->{var},$config->{value});
	 			$varFound = 1; 
	 		} else {
	 			$fileoutput .= writeLine($var,$value);
	 		}
		}
	}

	if (! $varFound) {
		$fileoutput .= writeLine($config->{var},$config->{value});
	}

	my $writeFileErrors;
	eval {                                                          
		local *OUTPUTFILE;
		if( open OUTPUTFILE, ">", $filename) {
			print OUTPUTFILE $fileoutput;
			close OUTPUTFILE;
		} else {
			$writeFileErrors = "I could not open $fileoutput".
				"We will not be able to make configuration changes unless the permissions are set so that the web server can write to this file.";
		}
	};  # any errors are caught in the next block

	$writeFileErrors = $@ if $@;

	if ($writeFileErrors){
		return {error=>$writeFileErrors};
	} else {
		if($config->{type} eq 'boolean'){
			$config->{value} = $config->{value} ? JSON::true : JSON::false;
		}
		return $config;
	}
}

sub writeLine {
	my ($var,$value) = @_;
	my $val = (ref($value) =~/ARRAY/) ? to_json($value,{pretty=>0}): $value;
	$val = "'".$val . "'" if ($val =~ /^[\w\s\/]+$/);
	#$val =~ s/'//g;
	return "\$" . $var . " = " . $val . ";\n";
}




1;