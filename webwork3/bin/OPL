#!/usr/bin/perl
use strict;
use warnings;
use feature 'say';
 
use Moo;
use MooX::Options;
use File::Find::Rule;
use List::MoreUtils qw/first_index/;
use Data::Dump qw/dd/;
use File::Slurp qw/read_file/;
use MongoDB;
use YAML qw(LoadFile DumpFile);
use Carp::Always;
use Path::Class;

use lib '../lib';

use Models::Library::Constant qw/$DATABASE $COURSE/;
use Models::Library::Problem;


use Utils::PGParse;

option dbtype => (is=>'ro', format=>'s',
    doc => 'This is the database type.  Currently only MYSQL and MONGO have been defined.', default=>"MONGO");
option library_directory => (is=>'ro',format=>'s', 
    doc => 'This is the directory where the library is defined relative to the library_base.');
option library_base => (is=>'ro',format=>'s',
    doc => '');
option dbname => (is=>'ro',format=>'s', default => 'testOPL',
    doc => 'This is the name of the database to use for storing a retrieving from the library');
option action => (is=>'ro', format => 's',
    doc => 'This is the action to do.  Currently only rebuildDB and search have been defined.');
option dbuser => (is=>'ro',format => 's', default=>'webworkWrite',
    doc => 'This is the username of the database.');
option dbpass => (is=>'ro',format => 's', default=>'passwordRW',
    doc => 'This is the password for the database.');
option finddb => (is=> 'ro',format=>'s@', repeatable=> 1, autosplit=>";",
    doc => 'This is the list of items to search for in the database.');
    
option dbinfo => (is=> 'ro',format=>'s',
    doc => 'This queries the database for certain fields.');

my @dbtables = qw/OPL_DBsubject OPL_DBchapter OPL_DBsection OPL_author OPL_textbook OPL_chapter OPL_section OPL_problem 
                    OPL_keyword OPL_path OPL_morelt OPL_pgfile OPL_pgfile_problem OPL_pgfile_keyword/;
my @subjects;
my @chapters;
my $taxon;
my $logfile = 'opl.log';

sub run {
    my $self = shift;

    $DATABASE->{type} = $self->dbtype;

    # Connect to database
    if ($DATABASE->{type} eq "MYSQL"){
        my $dbname = $self->dbname;
        my $dbuser = $self->dbuser;
        my $dbpass = $self->dbpass;
        print "connecting to MYSQL database with database name: $dbname and user: $dbuser\n";
        DBIx::Mint->connect("dbi:mysql:dbname=$dbname", $dbuser,$dbpass, {
            AutoCommit    => 1,
            RaiseError    => 1,
        });
    } elsif ($DATABASE->{type} eq "MONGO") {
        print "connecting to MONGO database\n";
        $DATABASE->{MONGOclient} = MongoDB::MongoClient->new;
        $DATABASE->{dbname} = $self->dbname;
    } else {
        die "The database type $DATABASE->{type} is not allowed.  Only MYSQL and MONGO have been defined.";
    }

    if(defined($self->action) && $self->action eq 'rebuildDB') {
        $self->rebuildDB;
    } elsif(defined($self->action) && $self->action eq 'search') {
        die "The option finddb must be defined" unless defined($self->finddb);
        $self->search;
    } elsif(defined($self->action) && $self->action eq 'dbinfo') {
        $self->showDbinfo; 
    } else {
        my $action = $self->action || '' ;
        die "The only options are 'rebuildDB', 'dbinfo' and 'search'.  You selected $action";
    }
}

sub rebuildDB {
    my $self = shift;
    my $start = time();
    
    print "Building a database of type: $DATABASE->{type} \n"; 


    $| = 1;  # disable the print buffer
    
    my @problems_not_in_db = (); 

    my $taxfile ='tax.yml';
    my $tbLinkFile = 'textbooks.yml';

    $COURSE->{log_file} = '/Library/WebServer/Documents/webwork/webwork2/webwork3/environments/logs/prob_not_in_db.yml';
    $COURSE->{library_base} = '/Library/WebServer/Documents/webwork/libraries/webwork-open-problem-library/OpenProblemLibrary/';
    #my $default_dir = 'WHFreeman/Rogawski_Calculus_Early_Transcendentals_Second_Edition/11_Parametric_Equations_Polar_Coordinates_and_Conic_Sections/11.4_Area_and_Arc_Length_in_Polar_Coordinates';
    #my $default_dir = '/Library/WebServer/Documents/webwork/libraries/webwork-open-problem-library/OpenProblemLibrary/Rochester';
    my $default_dir = '.';
    my $lib_dir = $self->library_directory || $default_dir; 
    my $dir = dir($COURSE->{library_base},$lib_dir)->cleanup;
    print "Building the OPL database for the library found at:\n " . $dir->stringify . "\n";

    $self->recreateDB();

    print "Loading the Taxonomy File: $taxfile \n";
    $taxon = LoadFile($taxfile);
    @subjects = map { $_->{name} } @{$taxon->{subjects}};
    @chapters =(); 

    # load the textbook link file
    print "Loading the Textbooks File: $tbLinkFile \n";
    my $tb_link_file = LoadFile($tbLinkFile);
    
    my @pgfiles = File::Find::Rule->file()->name('*.pg')->in($dir->stringify);

    my $path = dir($COURSE->{library_directory},$pgfiles[0]);

    print "Rebuilding the Database... \n";
    for my $i (0 .. $#pgfiles) {
        my $parser = Utils::PGParse->new(problem_path=>$pgfiles[$i],library_dir=>$COURSE->{library_base});
        my $prob = $parser->parse;

        printf "%6s",$i if ($i>0 && $i % 100 == 0);
        print "\n" if ($i>0 && $i % 1000 == 0);
        my $msg = isValid($prob,$taxon,$i);
        if ($prob->isLink){
            push(@problems_not_in_db,{message => "The problem is a link",path=>$prob->path});
        } elsif(length($msg)>0){
            push(@problems_not_in_db,{message => $msg,path=>$prob->path});
        } else {
            $prob->insert;
        }
    }

    print "\nLibrary database rebuilt.\n";

    DumpFile($COURSE->{log_file},\@problems_not_in_db);
    
    print "Problems not in the databse written to: \n";
    print $COURSE->{log_file} . "\n";

    if($DATABASE->{type} eq 'MONGO') {
        print "building indexes in MONGO\n";
        my $idx = Tie::IxHash->new(DBsubject => 1, DBchapter => 1, DBsection => 1, keyword=>1, level=>1);
        my $db = $DATABASE->{MONGOclient}->get_database($DATABASE->{dbname});
        my $problems = $db->get_collection('problems');
        $problems->ensure_index($idx);
        $problems->ensure_index({statement => "text"}, {language_override=>"DDDD"}); # make a dummy language field
    }
    
    
    my $timediff = time() - $start;

    print "Amount of time is $timediff seconds.\n";

}

sub recreateDB {
    my $self = shift; 
    print "Recreating the Database tables\n";
    
    my $dbname = $self->dbname || 'testOPL';
    
    if($DATABASE->{type} eq 'MYSQL'){
        my $mint  = DBIx::Mint->instance;  

        ## drop all of the tables
        my $dbh  = $mint->dbh;

        for my $table (@dbtables) {
            #print "DROP TABLE IF EXISTS $table ;\n";
            $dbh->do('DROP TABLE IF EXISTS '.$table.';');
        }
        ## then create them
        my $buildDB = read_file('setup_db.sql');
        my @commands = split(';',$buildDB);

        for my $command (@commands){
            #print "command: " . $command . "\n";
            $dbh->do($command.';');
        }
    } elsif($DATABASE->{type} eq 'MONGO'){
        my $db = $DATABASE->{MONGOclient}->get_database($DATABASE->{dbname});
        my $problems = $db->get_collection('problems');
        $problems->remove({});  # remove all problems;
        my $tbprobs = $db->get_collection('textbook_problems');
        $tbprobs->remove({});
        
    }
    print "Finished recreating the Database tables\n";
}

sub isValid {
    my ($prob,$taxon,$i) = @_;
    #if(! defined($prob->DBinfo)){
    #    return;
    #}
    if($prob->DBinfo->DBsubject  eq "ZZZ-Inserted Text" || 
        $prob->DBinfo->DBchapter  eq "ZZZ-Inserted Text" || 
        $prob->DBinfo->DBsection  eq "ZZZ-Inserted Text") {
        return "contains ZZZ-Inserted Text";
    }
    if($prob->DBinfo->DBsubject  eq "" || 
        $prob->DBinfo->DBchapter  eq "" || 
        $prob->DBinfo->DBsection  eq "") {
        return "db info blank";
    }

    
    my $name = $prob->DBinfo->DBsubject;
    my $sname = "subject";  # name of the subject, chapter or section 
    my $sub_found = first_index { $_ eq $prob->DBinfo->DBsubject} @subjects;
    #print $name . " " . $prob->path . "\n";
    if ($sub_found > -1) {
        $name = $prob->DBinfo->DBchapter; 
        $sname = "chapter";
        
        @chapters = map { $_->{name} }  @{$taxon->{subjects}[$sub_found]->{chapters}};
        my $chap_found = first_index { $_ eq $prob->DBinfo->DBchapter} @chapters;
        
        if($chap_found > -1 ) {
            $name = $prob->DBinfo->DBchapter;
            $sname = "chapter";
            if($taxon->{subjects}[$sub_found]->{chapters}[$chap_found]->{sections}){
                my @sections = @{$taxon->{subjects}[$sub_found]->{chapters}[$chap_found]->{sections}};
                #push(@sections,@valid_names);
                $name = $prob->DBinfo->DBsection;
                $sname = "section"; 
                my $sect_found = first_index { $_ eq $prob->DBinfo->DBsection} @sections;
                #print $sect_found . "\n";
                if ($sect_found > -1 ) {
                    return ""; 
                } else {
                    $name = $prob->DBinfo->DBsection;
                    $sname = "section"; 
                }
            } else {
                return "";
            }
        } 
    }

    return "";  # this returns the msg, if empty then valid. 
}

my @fields = qw/DBsubject DBchapter DBsection lastname firstname institution level keyword/;

sub search {
    my $self = shift;
    my $params = {};
    for my $obj (@{$self->finddb}){
        my @results = split(":",$obj);
        if(grep {$_ eq $results[0] } @fields){
            $params->{$results[0]} = $results[1];
        } else {
            die "The field " . $results[0] . " is not an available search term.";
        }
    }
    dd $params; 
    my @find = Models::Library::Problem->find($params);
    
    dd @find;
}

sub showDbinfo {
    my $self = shift;
    my $num_documents = Models::Library::Problem->count; 
    print "The number of documents in the database is: $num_documents\n";
    if( defined($self->dbinfo) &&  (grep {$self->dbinfo eq $_ } @fields)){
        my @unique_results = Models::Library::Problem->unique_results($self->dbinfo);
        dd @unique_results;
    } else {
        say "The field " . $self->dbinfo . " is not an available database term.";
    }
    
}

main->new_with_options->run;

1;